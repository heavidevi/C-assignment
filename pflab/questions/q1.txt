HARDCORE C PROGRAMMING TEST QUESTIONS
=====================================
Lab 03-06: Advanced C Programming Concepts
Prepared for: Tomorrow's Test
Difficulty Level: LeetCode/MIT/Harvard CS50 Style

QUESTION #1: Advanced Memory Pattern Analysis
=============================================
Write a program that takes an integer n (1 ≤ n ≤ 1000) and performs the following operations:
1. Calculate the sum of all prime factors of n
2. For each digit in this sum, perform bitwise XOR with its position (1-indexed)
3. If the final result is even, print a diamond pattern of height n using only bitwise operations
4. If odd, print an inverted diamond using bit manipulation for spacing calculations

Constraints:
- No arrays allowed, use only individual variables
- Must use all three loop types (for, while, do-while) in different sections
- Implement prime factorization using only bitwise operations for optimization
- Handle edge cases: n=1, perfect squares, prime numbers

Example:
Input: 30
Prime factors: 2, 3, 5 → Sum = 10
Digits: 1,0 → 1^1 XOR 0^2 = 1 XOR 0 = 1 (odd)
Output: Inverted diamond of height 30

QUESTION #2: Cryptographic Number Validator
==========================================
Implement a number validation system that checks if a given number satisfies ALL conditions:
1. Number must be between 10000-99999 (5 digits)
2. Sum of digits at even positions equals sum of digits at odd positions
3. Number must be divisible by the XOR of its first and last digit
4. When converted to binary, it must have equal number of 0s and 1s in positions that are prime indices
5. The number, when each digit is raised to the power of its position, and all results XORed together, must be a perfect square

Additional Requirements:
- Use nested loops with continue/break statements strategically
- Implement custom power function using only loops (no math.h)
- Handle integer overflow detection manually
- Display intermediate calculations in binary format

Test Cases:
- Input: 12321 → Check all conditions step by step
- Input: 54545 → Should fail at condition 4
- Input: 23232 → Should pass all conditions

QUESTION #3: Matrix Spiral Pattern Generator (No Arrays!)
========================================================
Create a program that generates a spiral pattern of numbers without using arrays:
1. Take dimensions m×n from user (1 ≤ m,n ≤ 50)
2. Fill the matrix in spiral order: right → down → left → up
3. At each position (i,j), place the value: (i^j) & (i|j) ^ (i<<1)
4. Display the pattern such that:
   - Prime numbers are displayed in binary
   - Even numbers are displayed in octal  
   - Odd numbers are displayed in hexadecimal
5. Calculate and display the sum of all corner elements using bitwise operations only

Constraints:
- Cannot use arrays - simulate matrix using mathematical calculations
- Must validate that the spiral is correctly generated by checking adjacent elements
- Use different loop types for different directions of spiral
- Handle rectangular matrices (m≠n) correctly

Example for 3×3:
Position (0,0): (0^0) & (0|0) ^ (0<<1) = 1 & 0 ^ 0 = 0
Spiral order: 0,1,2,5,8,7,6,3,4

QUESTION #4: Advanced Palindromic Number System
==============================================
Write a program that finds all "Super Palindromes" in a given range [L,R]:
A Super Palindrome is a number that satisfies:
1. The number itself is a palindrome
2. Its binary representation is also a palindrome
3. The sum of its digits is a palindrome
4. When digits are alternately added and subtracted (d1-d2+d3-d4+...), result is palindrome

Additional Operations:
1. For each Super Palindrome found, generate a "Palindrome Tree":
   - Root is the original number
   - Each level contains palindromes formed by various digit manipulations
   - Display tree using ASCII art with proper spacing
2. Calculate the "Palindrome Signature": XOR of all Super Palindromes found
3. Determine if this signature, when converted to different bases (2,8,16), forms palindromes

Range: 1000 ≤ L ≤ R ≤ 100000
Output: All Super Palindromes with their trees and final signature analysis

QUESTION #5: Bitwise Fibonacci Matrix Exponentiation
===================================================
Implement an ultra-efficient Fibonacci calculator that can handle F(n) where n ≤ 10^6:
1. Use matrix exponentiation method: [[1,1],[1,0]]^n
2. Implement matrix multiplication using ONLY bitwise operations
3. Use fast exponentiation with binary representation of n
4. For each step, display:
   - Current exponent in binary
   - Matrix state after each multiplication
   - Running XOR checksum of all intermediate results

Advanced Requirements:
1. Detect and handle integer overflow using bitwise overflow detection
2. Implement modular arithmetic using bitwise operations (mod 1000000007)
3. Create a "Fibonacci Spiral Visualization" where:
   - Each Fibonacci number F(i) is placed at position determined by bit rotation
   - Display connections between numbers using ASCII art
   - Color-code (using different characters) based on parity

Bonus Challenge:
- Calculate F(n) mod (2^k) for k=1,2,4,8,16,32 simultaneously using bit masking
- Find pattern in last k bits of Fibonacci sequence

QUESTION #6: Multi-Base Arithmetic Expression Evaluator
======================================================
Create a calculator that evaluates expressions containing numbers in different bases:
Input: "1010b + 77o * 2Fh - 25d"  (binary + octal * hex - decimal)
Operations:
1. Parse and convert all numbers to decimal using only loops and bitwise operations
2. Evaluate expression following operator precedence
3. Display result in ALL bases (2,8,10,16) with proper formatting
4. Show step-by-step evaluation with base conversions at each step

Advanced Features:
1. Handle parentheses and nested expressions
2. Support bitwise operators: &, |, ^, <<, >>
3. Implement "Smart Parentheses": automatically add parentheses to make expression evaluate to a palindromic result
4. Error handling: invalid digits for given base, overflow detection

Example Execution:
Input: "1101b & 17o | FFh"
Step 1: 1101b = 13d, 17o = 15d, FFh = 255d  
Step 2: 13 & 15 = 13d
Step 3: 13 | 255 = 255d
Final: 255d = 11111111b = 377o = FFh

QUESTION #7: Advanced String Processing Without Strings
======================================================
Process text input character by character to solve multiple problems simultaneously:
Given a sentence, perform ALL operations in a single pass:
1. Count frequency of each character (a-z, A-Z, 0-9) using only individual variables
2. Find the longest palindromic subsequence length
3. Generate all possible acronyms (first letters of words)
4. Calculate a "Text Signature": XOR of ASCII values weighted by position and frequency
5. Determine if rearranging characters can form a palindrome

Output Requirements:
1. Display character frequency histogram using ASCII art
2. Show palindromic subsequence with highlighting
3. List all acronyms with their binary representations
4. Verify text signature using checksum algorithm
5. Provide proof of palindrome possibility with construction steps

Constraints:
- No arrays/strings - use individual char variables for processing
- Handle input up to 1000 characters
- Use different loop types for different operations
- Must process everything in O(n) time complexity

QUESTION #8: Hybrid Number System Converter & Analyzer
=====================================================
Create a comprehensive number analysis system:
Input: Any integer (positive/negative, up to 64-bit)
Perform ALL analyses:

1. **Base Conversion Matrix**: Convert to bases 2,3,4,5,6,7,8,9,10,11,12,16
2. **Digital Root Calculation**: For each base, find digital root using repeated digit sum
3. **Palindrome Detection**: Check if number is palindromic in ANY of the bases
4. **Prime Base Analysis**: Determine if number is prime when interpreted in different bases
5. **Bitwise Pattern Analysis**: Find repeating patterns in binary representation
6. **Mathematical Properties**: Check for perfect square, cube, triangular number, etc.

Advanced Output:
- Create a "Number DNA" visualization showing properties across all bases
- Generate "Conversion Tree" showing relationships between base representations  
- Calculate "Universal Hash" using XOR of all base representations
- Predict next number in sequence that shares similar properties

Special Cases:
- Handle negative numbers using two's complement
- Detect and display overflow conditions
- Handle edge cases: 0, 1, MAX_INT, MIN_INT

QUESTION #9: Loop Performance Analyzer & Optimizer
=================================================
Write a program that implements the SAME algorithm using all three loop types and analyzes performance:
Algorithm: Calculate sum of all numbers from 1 to N that satisfy:
- Number is prime
- Binary representation has equal 0s and 1s  
- Sum of digits is a perfect square
- Number reversed is also prime

Implementation Requirements:
1. Implement using FOR loop with detailed step counting
2. Implement using WHILE loop with different optimization strategy
3. Implement using DO-WHILE loop with early termination conditions
4. Compare actual steps taken by each approach

Analysis Output:
- Display iteration count for each loop type
- Show memory access patterns
- Calculate efficiency ratio
- Recommend optimal loop type for this specific problem
- Provide mathematical proof of why one approach is superior

Range: 1 ≤ N ≤ 100000
Expected: Deep analysis of loop behavior and performance characteristics

QUESTION #10: Recursive Pattern Simulator (Using Only Loops)
===========================================================
Simulate recursive algorithms using only iterative structures:
Implement Tower of Hanoi solution for N disks without recursion:
1. Use nested loops to simulate call stack
2. Track all intermediate steps and moves
3. Display visual representation of towers at each step using ASCII art
4. Calculate and verify that exactly 2^N - 1 moves are made
5. Implement "move validation" to ensure no illegal moves occur

Advanced Features:
1. **Multi-Tower Variant**: Solve for 4 towers (more efficient algorithm)
2. **Optimization Analysis**: Compare move count between 3-tower and 4-tower solutions
3. **Pattern Recognition**: Identify and display the recursive pattern in iterative form
4. **Memory Simulation**: Show how recursive call stack would look at each step

Visualization Requirements:
- ASCII art towers with proper disk representation
- Step-by-step animation (can be simulated with pauses)
- Move validation with error checking
- Performance metrics and complexity analysis

Constraints:
- No recursion allowed - only loops
- No arrays for stack simulation - use individual variables
- Handle N up to 10 disks
- Prove correctness by checking final configuration

===============================================
BONUS CHALLENGE QUESTION:
===============================================
Implement a "C Programming Language Interpreter" that can execute a subset of C code:
- Support: variables, arithmetic, loops, conditions
- Parse and execute simple C statements input as text
- Handle nested loops and complex expressions
- Provide debugging output showing variable states
- All without using advanced data structures!

Good luck with your test! These questions will truly test your hardcore C programming skills! 🚀
